class Collective::LinkedList does Iterable {
    has Mu $.value;
    has ::?CLASS:D $.next;
    method !SET-SELF(Mu \value, ::?CLASS:D \next --> ::?CLASS:D) {
        $!value := value;
        $!next  := next;
        self;
    }

    sub linkedlist(|init --> ::?CLASS:D) is export {
        ::?CLASS.new(|init);
    }

    proto method new(|) {*}
    multi method new( --> ::?CLASS:D) {
        my $self := self.CREATE;
        $self!SET-SELF(IterationEnd, $self);
    }
    multi method new(Mu :$value! is raw, ::?CLASS:D :$next = self.new
                      --> ::?CLASS:D) {
        $next.insert($value);
    }
    multi method new(+values, Bool() :$reversed --> ::?CLASS:D) {
        X::Cannot::Lazy.new(:action<link the values generated by>).throw
          if values.is-lazy;

        my $node := self.new;
        $node := $node.insert($_) for $reversed ?? values !! values.reverse;
        $node;
    }

    proto method insert(::?CLASS:D: Mu $value --> ::?CLASS:D) {*}
    multi method insert(Mu \value is readonly) {
        self.CREATE!SET-SELF(value, self);
    }
    multi method insert(Mu $value is rw) {
        self.CREATE!SET-SELF($value<>, self);
    }

    my class ValueIterator does Iterator {
        has $.node;
        method pull-one(::?CLASS:D: --> Mu) {
            my \value = $!node.value;
            $!node .= next;
            value;
        }
    }
    multi method iterator(::?CLASS:D: --> Iterator:D) {
        ValueIterator.new(node => self);
    }
    multi method list(::?CLASS:D: --> List:D) {
        self.Seq.list;
    }

    multi method Bool(::?CLASS:D: --> Bool:D) {
        $!next !=:= self;
    }
}

=begin pod

=TITLE class Collective::LinkedList

=SUBTITLE Purely functional linked list

    class Collective::LinkedList does Iterable {}

A C<Collective::LinkedList> is a linear collection of immutable values.
Each value is stored in a node that points to the next node. The nodes
are also immutable, allowing distinct linked lists to share a common tail.

A C<Collective::LinkedList> is in fact the first node of a given linked
list. Every linked list is terminated by a sentinel node that evaluates to
C<False> in Boolean context. A non-empty linked list evaluates to C<True>.

=head1 Exports

=head2 sub linkedlist

Defined as:

    sub linkedlist(|init --> Collective::LinkedList:D)

Calls L<C<Collective::LinkedList.new>|#method_new> with the provided
arguments.

=head1 Methods

=head2 method new

Defined as:

    multi method new( --> ::?CLASS:D)
    multi method new(+values, Bool() :$reversed --> ::?CLASS:D)
    multi method new(Mu :$value! is raw, ::?CLASS:D :$next = self.new
                      --> ::?CLASS:D)

Creates and returns a new C<Collective::LinkedList>. If no values are
provided, the result is a sentinel node representing an empty linked list.

Values provided in a single, non-itemized C<Iterable> or an argument list
are stored in reverse order if the C<:reversed> adverb is used. This may
reduce resource consumption if the values are generated on demand.

If a named value is provided instead, it is L<inserted|#method_insert> into
the linked list headed by the C<$next> node.

=head2 method Bool

Defined as:

    multi method Bool(::?CLASS:D: --> Bool:D)

Returns C<True> if the linked list stores one or more proper values,
C<False> if the linked list is empty.

=head2 method value

Defined as:

    method value(::?CLASS:D:)

Returns the value stored in the first node of the linked list. Note that
this is the sentinel value C<IterationEnd> if the list is empty.

=head2 method next

Defined as:

    method next(::?CLASS:D:)

Returns the next node of the linked list. Note that this is the invocant
self if the list is empty.

=head2 method insert

Defined as:

    method insert(::?CLASS:D: Mu $value --> ::?CLASS:D)

Creates and returns a new C<Collective::LinkedList> node that stores the
provided value and points to the invocant as the next node.

=head2 method iterator

Defined as:

    multi method iterator(::?CLASS:D: --> Iterator:D)

Returns an C<Iterator> over the values stored in the linked list. Note that
the iterator is a mutable object that should not be used concurrently.

=head2 method list

Defined as:

    multi method list(::?CLASS:D: --> List:D)

Returns a C<List> providing positional access to the values stored in the
linked list.

=end pod
