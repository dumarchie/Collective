use Collective::Linked ();

class Collective::LinkedList does Collective::Linked does Iterable {
    method empty( --> ::?CLASS:D) {
        my $self := self.CREATE;
        $self!SET-SELF(IterationEnd, $self);
    }

    multi method Bool(::?CLASS:D: --> Bool:D) {
        $!rest !=:= self;
    }

    multi method new( --> ::?CLASS:D) {
        self.empty;
    }
    multi method new(+values, *%options --> ::?CLASS:D) {
        self.empty.prepend(values, |%options);
    }
    multi method new(Mu :$value!, *%attrinit --> ::?CLASS:D) {
        self.bless(:$value, |%attrinit);
    }

    multi method prepend(::?CLASS:D: +values, :$reversed --> ::?CLASS:D) {
        X::Cannot::Lazy.new(:action<link the values generated by>).throw
          if values.is-lazy;

        my $list := self;
        values.VAR ~~ Scalar ?? $list.insert(values) !! do {
            $list := $list.insert($_)
              for $reversed ?? values !! values.reverse;
            $list;
        }
    }

    my class ValueIterator does Iterator {
        has $.list;
        method pull-one(::?CLASS:D: --> Mu) {
            my \value = $!list.value;
            $!list .= rest;
            value;
        }
    }
    multi method iterator(::?CLASS:D: --> Iterator:D) {
        ValueIterator.new(list => self);
    }
    multi method list(::?CLASS:D: --> List:D) {
        self.Seq.list;
    }
}

my \Empty = Collective::LinkedList.new;
sub linkedlist(|values --> Collective::LinkedList:D) is export {
    Empty.prepend(|values);
}

=begin pod

=TITLE class Collective::LinkedList

=SUBTITLE Purely functional linked list

    class Collective::LinkedList does Collective::Linked does Iterable { }

A C<Collective::LinkedList> is a linear collection of immutable values. It
is a recursive data structure consisting of a I<value> and linked list with
the I<rest> of the values. Because the collection itself is also immutable,
distinct linked lists can share a common tail. For example:

    my $a = linkedlist <foo bar>;
    my $b = $a.insert('baz');
    my $c = $a.insert('qux');
    say $b.rest === $c.rest; # OUTPUT: «True␤»

=head1 Exports

=head2 sub linkedlist

Defined as:

    sub linkedlist(|values --> Collective::LinkedList:D)

L<Prepends|#method_prepend> to a shared empty linked list.

=head1 Methods

=head2 method empty

Defined as:

    method empty( --> ::?CLASS:D)

Returns a sentinel node representing an empty linked list. This node has
value C<IterationEnd> and its C<.rest> is the empty linked list C<self>.

=head2 method Bool

Defined as:

    multi method Bool(::?CLASS:D: --> Bool:D)

Returns C<False> if and only if the linked list is empty.

=head2 method new

Defined as:

    multi method new( --> ::?CLASS:D)
    multi method new(+values, *%options --> ::?CLASS:D)
    multi method new(Mu :$value!, *%attrinit --> ::?CLASS:D)

Creates a new C<Collective::LinkedList>. This is an L<empty|#method_empty>
list if neither positional C<values> nor a named C<$value> is provided. If
C<values> are provided, they are L<prepended|#method_prepend> to the empty
list. If a named C<$value> is provided instead, the arguments are used to
L<build|https://docs.raku.org/routine/bless> a new linked list node.

=head2 method prepend

Defined as:

    multi method prepend(::?CLASS:D: +values, :$reversed --> ::?CLASS:D)

Returns a I<new> C<Collective::LinkedList> that stores the provided
I<values> in front of the original list. The provided values are stored in
reverse order if the C<:reversed> adverb is used. For example:

    # linkedlist(values) is short for linkedlist.prepend(values)
    my $list = linkedlist <foo bar>, :reversed;
    say $list.value; # OUTPUT: «bar␤»

=head2 method iterator

Defined as:

    multi method iterator(::?CLASS:D: --> Iterator:D)

Returns an C<Iterator> over the values stored in the linked list. Note that
the I<iterator> is a mutable object that should not be used concurrently.

=head2 method list

Defined as:

    multi method list(::?CLASS:D: --> List:D)

Returns a C<List> providing positional access to the values stored in the
linked list. Note that the C<List> is based on the linked list's iterator,
so it's probably not safe to access its elements from multiple threads
until the C<List> is fully reified, for example by calling C<.elems> on it.

=head1 Methods supplied by role Collective::Linked

Collective::LinkedList does role L<Collective::Linked> which provides the
following methods:

=head2 method value

Returns the value at the head of the linked list. Note that this is the
sentinel value C<IterationEnd> if the list is empty.

=head2 method rest

Returns the rest of the linked list. Note that this is the linked list self
if the list is empty.

=head2 method insert

Defined as:

    multi method insert(::?CLASS:U: Mu \value)
    multi method insert(::?CLASS:U: Mu $value is rw)
    multi method insert(::?CLASS:D: Mu \value)
    multi method insert(::?CLASS:D: Mu $value is rw)

Returns a I<new> C<Collective::LinkedList> with the provided C<value> or
decontainerized C<$value> at the head. The L<rest|#method_rest> of the list
is the invocant self, or the L<empty|#method_empty> list if the invocant is
not defined.

=end pod
