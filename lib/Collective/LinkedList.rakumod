class Collective::LinkedList does Iterable {
    has Mu $.value;
    has ::?CLASS:D $.next;
    method !SET-SELF(Mu \value, ::?CLASS:D \next --> ::?CLASS:D) {
        $!value := value;
        $!next  := next;
        self;
    }

    proto method new(|) {*}
    multi method new( --> ::?CLASS:D) {
        my $self := self.CREATE;
        $self!SET-SELF(IterationEnd, $self);
    }
    multi method new(|values --> ::?CLASS:D) {
        self.new.prepend(|values);
    }
    multi method new(Mu :$value! is raw, ::?CLASS:D :$next = self.new
                      --> ::?CLASS:D) {
        $next.insert($value);
    }

    proto method insert(|) {*}
    multi method insert(::?CLASS:D: Mu \value --> ::?CLASS:D) {
        self.CREATE!SET-SELF(value, self);
    }
    multi method insert(::?CLASS:D: Mu $value is rw --> ::?CLASS:D) {
        self.CREATE!SET-SELF($value<>, self);
    }

    multi method prepend(::?CLASS:D: +values, Bool() :$reversed
                          --> ::?CLASS:D) {
        X::Cannot::Lazy.new(:action<link the values generated by>).throw
          if values.is-lazy;

        my $node := self;
        values.VAR ~~ Scalar ?? $node.insert(values) !! do {
            $node := $node.insert($_)
              for $reversed ?? values !! values.reverse;
            $node;
        }
    }

    my class ValueIterator does Iterator {
        has $.node;
        method pull-one(::?CLASS:D: --> Mu) {
            my \value = $!node.value;
            $!node .= next;
            value;
        }
    }
    multi method iterator(::?CLASS:D: --> Iterator:D) {
        ValueIterator.new(node => self);
    }
    multi method list(::?CLASS:D: --> List:D) {
        self.Seq.list;
    }

    multi method Bool(::?CLASS:D: --> Bool:D) {
        $!next !=:= self;
    }
}

my \Empty = Collective::LinkedList.new;
sub linkedlist(|values --> Collective::LinkedList:D) is export {
    Empty.prepend(|values);
}

=begin pod

=TITLE class Collective::LinkedList

=SUBTITLE Purely functional linked list

    class Collective::LinkedList does Iterable {}

A C<Collective::LinkedList> is a linear collection of immutable values.
Each value is stored in a node that points to the next node. The nodes
are also immutable, allowing distinct linked lists to share a common tail.

A C<Collective::LinkedList> is in fact the first node of a given linked
list. Every linked list is terminated by a sentinel node that evaluates to
C<False> in Boolean context. A non-empty linked list evaluates to C<True>.

=head1 Exports

=head2 sub linkedlist

Defined as:

    sub linkedlist(|values --> Collective::LinkedList:D)

L<Prepends|#method_prepend> to a shared empty linked list.

=head1 Methods

=head2 method new

Defined as:

    multi method new( --> ::?CLASS:D)
    multi method new(|values --> ::?CLASS:D)
    multi method new(Mu :$value! is raw, ::?CLASS:D :$next = self.new
                      --> ::?CLASS:D)

Returns a new C<Collective::LinkedList>. Calls L<.prepend|#method_prepend>
on a new linked list if positional arguments are provided. Calls
L<.insert|#method_insert> on the C<$next> node if a named C<$value> is
provided instead.

=head2 method insert

Defined as:

    multi method insert(::?CLASS:D: Mu \value --> ::?CLASS:D)
    multi method insert(::?CLASS:D: Mu $value is rw --> ::?CLASS:D)

Creates and returns a I<new> C<Collective::LinkedList> node that stores the
decontainerized I<value> of the positional argument in front of the
original list.

=head2 method prepend

Defined as:

    multi method prepend(::?CLASS:D: +values, Bool() :$reversed
                          --> ::?CLASS:D)

Returns a I<new> C<Collective::LinkedList> that stores the provided
I<values> in front of the original list. The provided values are stored in
reverse order if the C<:reversed> adverb is used.

=head2 method Bool

Defined as:

    multi method Bool(::?CLASS:D: --> Bool:D)

Returns C<True> if the linked list stores one or more proper values,
C<False> if the linked list is empty.

=head2 method value

Defined as:

    method value(::?CLASS:D:)

Returns the value stored in the first node of the linked list. Note that
this is the sentinel value C<IterationEnd> if the list is empty.

=head2 method next

Defined as:

    method next(::?CLASS:D:)

Returns the next node of the linked list. Note that this is the invocant
self if the list is empty.

=head2 method iterator

Defined as:

    multi method iterator(::?CLASS:D: --> Iterator:D)

Returns an C<Iterator> over the values stored in the linked list. Note that
the I<iterator> is a mutable object that should not be used concurrently.

=head2 method list

Defined as:

    multi method list(::?CLASS:D: --> List:D)

Returns a C<List> providing positional access to the values stored in the
linked list. Note that the C<List> is based on the linked list's iterator,
so it may not be safe to access its elements concurrently until the C<List>
is fully reified, for example by calling C<.elems> on it.

=end pod
