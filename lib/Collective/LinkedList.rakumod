class Collective::LinkedList does Iterable {
    has Mu $.value;
    has ::?CLASS:D $.rest;
    method !SET-SELF(Mu \value, ::?CLASS:D \rest --> ::?CLASS:D) {
        $!value := value;
        $!rest  := rest;
        self;
    }

    proto method new(|) {*}
    multi method new( --> ::?CLASS:D) {
        my $self := self.CREATE;
        $self!SET-SELF(IterationEnd, $self);
    }
    multi method new(|values --> ::?CLASS:D) {
        self.new.prepend(|values);
    }
    multi method new(Mu :$value! is raw, ::?CLASS:D :$rest = self.new
                      --> ::?CLASS:D) {
        $rest.insert($value);
    }

    proto method insert(|) {*}
    multi method insert(::?CLASS:D: Mu \value --> ::?CLASS:D) {
        self.CREATE!SET-SELF(value, self);
    }
    multi method insert(::?CLASS:D: Mu $value is rw --> ::?CLASS:D) {
        self.CREATE!SET-SELF($value<>, self);
    }

    multi method prepend(::?CLASS:D: +values, Bool() :$reversed
                          --> ::?CLASS:D) {
        X::Cannot::Lazy.new(:action<link the values generated by>).throw
          if values.is-lazy;

        my $list := self;
        values.VAR ~~ Scalar ?? $list.insert(values) !! do {
            $list := $list.insert($_)
              for $reversed ?? values !! values.reverse;
            $list;
        }
    }

    my class ValueIterator does Iterator {
        has $.list;
        method pull-one(::?CLASS:D: --> Mu) {
            my \value = $!list.value;
            $!list .= rest;
            value;
        }
    }
    multi method iterator(::?CLASS:D: --> Iterator:D) {
        ValueIterator.new(list => self);
    }
    multi method list(::?CLASS:D: --> List:D) {
        self.Seq.list;
    }

    multi method Bool(::?CLASS:D: --> Bool:D) {
        $!rest !=:= self;
    }
}

my \Empty = Collective::LinkedList.new;
sub linkedlist(|values --> Collective::LinkedList:D) is export {
    Empty.prepend(|values);
}

=begin pod

=TITLE class Collective::LinkedList

=SUBTITLE Purely functional linked list

    class Collective::LinkedList does Iterable {}

A C<Collective::LinkedList> is a linear collection of immutable values. It
is a recursive data structure consisting of a I<value> and linked list with
the I<rest> of the values. Because the collection itself is also immutable,
distinct linked lists can share a common tail. For example:

    my $a = linkedlist <foo bar>;
    my $b = $a.insert('baz');
    my $c = $a.insert('qux');
    say $b.rest === $c.rest; # OUTPUT: «True␤»

An I<empty> linked list has the sentinel value C<IterationEnd> and its
I<rest> is the empty linked list self. To distinguish an empty linked list
from a linked list with at least one proper I<value>, only the latter
evaluates to C<True> in Boolean context.

=head1 Exports

=head2 sub linkedlist

Defined as:

    sub linkedlist(|values --> Collective::LinkedList:D)

L<Prepends|#method_prepend> to a shared empty linked list.

=head1 Methods

=head2 method new

Defined as:

    multi method new( --> ::?CLASS:D)
    multi method new(|values --> ::?CLASS:D)
    multi method new(Mu :$value! is raw, ::?CLASS:D :$rest = self.new
                      --> ::?CLASS:D)

Returns a new C<Collective::LinkedList>. Calls L<.prepend|#method_prepend>
on a new linked list if positional arguments are provided. Calls
L<.insert|#method_insert> on the C<$rest> if a named C<$value> is provided
instead.

=head2 method insert

Defined as:

    multi method insert(::?CLASS:D: Mu \value --> ::?CLASS:D)
    multi method insert(::?CLASS:D: Mu $value is rw --> ::?CLASS:D)

Creates and returns a I<new> C<Collective::LinkedList> that stores the
decontainerized I<value> of the positional argument in front of the
original list.

=head2 method prepend

Defined as:

    multi method prepend(::?CLASS:D: +values, Bool() :$reversed
                          --> ::?CLASS:D)

Returns a I<new> C<Collective::LinkedList> that stores the provided
I<values> in front of the original list. The provided values are stored in
reverse order if the C<:reversed> adverb is used. For example:

    # linkedlist(values) is short for linkedlist.prepend(values)
    my $list = linkedlist <foo bar>, :reversed;
    say $list.value; # OUTPUT: «bar␤»

=head2 method value

Defined as:

    method value(::?CLASS:D:)

Returns the value at the front of the linked list. Note that this is the
sentinel value C<IterationEnd> if the list is empty.

=head2 method rest

Defined as:

    method rest(::?CLASS:D:)

Returns the rest of the linked list. Note that this is the linked list self
if the list is empty.

=head2 method Bool

Defined as:

    multi method Bool(::?CLASS:D: --> Bool:D)

Returns C<True> if the linked list stores one or more proper values,
C<False> if the linked list is empty.

=head2 method iterator

Defined as:

    multi method iterator(::?CLASS:D: --> Iterator:D)

Returns an C<Iterator> over the values stored in the linked list. Note that
the I<iterator> is a mutable object that should not be used concurrently.

=head2 method list

Defined as:

    multi method list(::?CLASS:D: --> List:D)

Returns a C<List> providing positional access to the values stored in the
linked list. Note that the C<List> is based on the linked list's iterator,
so it's probably not safe to access its elements from multiple threads
until the C<List> is fully reified, for example by calling C<.elems> on it.

=end pod
